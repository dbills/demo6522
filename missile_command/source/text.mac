.include "system.mac"
.include "m16.mac"
.include "zerop.inc"

.importzp s_x,s_y

.macro      debug_string s
            .local mystring
.data
mystring:
            .asciiz s
.code
          mov #mystring, ptr_string
          jsr _debug_string
.endmacro

.macro       debug_number mem
          saveall
          .if (.match (.left (1, {mem}), X))
          txa
          .elseif (.match (.left (1, {mem}), Y))
          tya
          .elseif (.match (.left (1, {mem}), A))
          ;; load the saved accumulator
          tsx
          lda $100+3,x
          .else
          lda mem
          .endif
          jsr _debug_number
          resall
.endmacro

.macro    _myprintf s,a1,a2,a3
.local mystring, done
.data
mystring:
            .asciiz s
.code
            .ifnblank a1
            pushw #a1
            .endif
            .ifnblank a2
            pushw #a2
            .endif
            .ifnblank a1
            pushw #a1
            .endif
            mov #mystring, ptr_string
            jsr _myprintf
            .ifnblank a1
            pla
            pla
            .endif
            .ifnblank a2
            pla
            pla
            .endif
            .ifnblank a1
            pla
            pla
            .endif
done:     
.endmacro

.macro    myprintf2 p1, p2, s, a1, a2, a3
          .local done
          saveall
          lda frame_cnt
          bne done
          te_clearpos p1,p2
          ;te_pos p1,p2
          _myprintf s, a1, a2, a3
done:     
          resall
.endmacro

.macro    myprintf s, a1, a2, a3
          saveall
          _myprintf s,a1,a2,a3
          resall
.endmacro
;;; Positions the text cursor
;;; IN:
;;;   px: x position
;;;   py: y position
;;; OUT:
;;;   s_x: x position of cursor
;;;   s_y: y position of cursor
.macro    te_pos px, py
          pha
.if (.match (.left (1, {px}), #))
            lda #(.right (.tcount ({px})-1, {px}))
.else
            lda px
.endif
          sta s_x
.if (.match (.left (1, {py}), #))
            lda #(.right (.tcount ({py})-1, {py}))
.else
            lda py
.endif
          sta s_y
          pla
.endmacro

;;; Clear the text line at screen coodinates
;;; IN:
;;;   px: x position
;;;   py: y position
;;; OUT:
;;;   s_x: x position of cursor
;;;   s_y: y position of cursor
.macro    te_clearpos px, py
          te_pos px,py
          jsr te_clear_line
.endmacro

.macro      cr
            lda #0
            sta s_x
.endmacro

.macro      crlf
            pha
            lda #0
            sta s_x
            add8 #8,s_y
            pla
.endmacro

;;; print direct array contents
.macro    direct_access array
          lda array,y
.endmacro
;;; Prints an array to hires screen
;;; IN:
;;;   start: integer index of array begin
;;;   end:   integer index of array end
;;;   accessor: a piece of assembly code that can fetch the array value
;;;             into A
.macro    print_array_ start,end,accessor
          .local loop,done
          ldy start
loop:
          accessor
          sta scratch
          myprintf "%d,", scratch
          cpy end
          beq done
          iny
          jmp loop
done:     
.endmacro

;;; Prints an array to hires screen
;;; e.g. 
;;;   foo: dc.b 12 13 14
;;;   print_array foo, 0, 3
;;; 
;;; would print:
;;;   12, 13, 14 on the screen
;;; 
;;; IN:
;;;   start: integer index of array begin
;;;   end:   integer index of array end
.macro    print_array array,start,end
          print_array_ start,end,{direct_access array}
.endmacro

;;; Prints an indirect array to hires screen
;;; e.g. 
;;;   foo:    dc.b 12 13 14
;;;   array1: dc.w foo, foo + 1, foo + 2
;;;   print_indirect_array array1, 0, 3
;;; 
;;; would print:
;;;   12, 13, 14 on the screen
;;; 
;;; IN:
;;;   start: integer index of array begin
;;;   end:   integer index of array end
;;; 
;;; TDB

