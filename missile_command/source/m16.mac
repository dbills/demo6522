;;; 16 bit macros
.ifndef _m16_h
_m16_h = 1
.macro      incw arg
.local done
            inc arg
            bne done
            inc arg + 1
done:       
.endmacro

.macro      decw _1
.local done
            lda  _1
            bne done
            dec _1 + 1
done:       
            sec
            sbc #1
            sta _1
.endmacro
;;; move word
.macro      mov src, dst
.if (.match (.left (1, {src}), #))
            lda #<(.right (.tcount ({src})-1, {src}))
            sta dst           
            lda #>(.right (.tcount ({src})-1, {src}))
            sta dst+1
.else
            lda src
            sta dst
            lda src+1
            sta dst+1
.endif
.endmacro
;;; move word immediate
.macro      movi _1,_2
            lda #.LOBYTE(_1)   ; load low byte
            sta _2             ; store low byte
            lda #.HIBYTE(_1)   ; load high byte
            sta _2+1           ; store high byte
.endmacro
;;; compare word
;;; _1 may be immediate or direct
;;; _2 is always direct
          .macro cmpw _1,_2
          .local done
.if (.match (.left (1, {_1}), #))
            lda #<(.right (.tcount ({_1})-1, {_1}))
.else
            lda [_1]
.endif
            cmp _2
            bne done
.if (.match (.left (1, {_1}), #))
            lda #>(.right (.tcount ({_1})-1, {_1}))
.else
            lda _1+1
.endif
            cmp _2+1
done:       
.endmacro

;;; compare _1 with #_2
;;; you can use beq,bne with this
.macro cmpi _1,_2
          .local done
          lda _1+1
          cmp #_2 >> 8       ; load high byte
          bne done
          lda _1
          cmp #[_2] & $ff    ; load low byte
done:       
.endmacro
;;; move,X source,dest
;;; equiv C code: 
;;; word array[]
;;; array[2] = array[1]
.macro movx _1,_2
          txa
          pha
          asl                         ; x*2 since it's a word
          tax
          lda [_1],x
          sta [_2],x
          inx
          lda [_1],x
          sta [_2],x
          pla
          tax
.endmacro
.endif
