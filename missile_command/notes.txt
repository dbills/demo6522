.dat: files with purely assembler generated data in them
.mac: files with only macros in them
.asm: source code files
.equ: public variables for routines

pick a one or two charcter prefix for subroutines
and public variables
e.g.

prefixes:

i_xxxx is an initialization routine
pl_x : x for the plot routine
BIT_ : a bitmap

suffixes:

_SZ : size of a table
_w : word
_h : high byte of word variable

naming:

constants (equates) caps
no mixed case

problems:
using underscore is dumb unless you widen you margins, you only have 9 chars right now
use X register for counter ( save the Y for indirect Y)
-------------------------
there is a equate/zerop technique for generating tables of objects
if we know ahead of time how many there will be
basically each header files "sets" the variables up and up
and zerop.asm will actually allocate the table using the 'repeat' function

N player interceptor + N enemy icbms + N explosion + 2 killer planes

icbms: only need x,y,speed
player missile: x,y
explosions: x,y,frame_num
            we can do interceptor and secondary explosions and city explosions with this
planes: x,y,frame_num, speed

thoughts:
hard code the spots for the 2 planes
dynamic strcture for icbms and explosions

collisions:
use a secondary bitmap and check for bit collisions
said bitmap would only contain explosion particles

total on screen object guesses:
30 icbm | explosions
have about at most 50 objects of this type in zero page.
we got tables and other crap -- zero page is gonna be really cramped
lets assume we can't put the all the dynamic data into zero page

can we take an early stab at what the hot spots might be for any of these tables that might need to be in the zero page?
player crosshair for sure
killer planes ( why not, they are fixed )

sprite routine inputs
if we use X as an index ( as panicman did )
lda s_xpos,X
    s_ypos,X
    s_speed,X
    s_frame 
multiply the frame counter by N and reload the source bitmap pointer
    s_source,X  ; bitmap source

i might need some kind of scheduler if I'm animating enough objects
that they can't all get done in one frame
how do you do that?
we know we need interrupt driven sound

what needs to be done before each frame.
anything you wanted to move has to be erased and moved in it's entirety
you've got to know how many updates you can make before the visible can lines start

----------------------------
line drawing subroutine
----------------------------
we need space for up to 30 lines to be drawn
because they are going to be put to screen at some slower rate
cost between using hard coded zp locations vs X indexed array

ZP,X 4 cycles
2 access to pl_x,pl_y, 4 instruction for 4 extra cycles

vs.
6 cycles to move * 2 = 12
x axis lines

what are the basic parts of this  X based line algo?


inputs x1,x2,y1,y2
variables: x_bmask_p : hold the current x pixel byte we are iterating through
           lstore_p : pointer to where to store line data in ram
it looks like we are going to need several 'index' bytes in zero page that will act as Y register offets
x_bmask_pidx: offset from xm_bmask_ptr
lstore_pidx: offset from lstore
dx,dy : dx can be the accumulator
cx: current x value
start_offset: bit position offset to start drawing bits
              after a Y shift this would be important for example
              

general routines needed ( not in any particular order )
calculate dx,dy values
calculate x%8 and 
increment x bit pointer
iterate along long axis
shift Y position ( may be up or down , macros will write subs for both )
write to screen

calcdydx  : already written
modulo8

decrement_x subroutine
            ldx x_bmask_pidx
            dex
            bne .done
            jsr reload            
.done

reload      subroutine
            mov_wi xbmask_tbl xbmask_tbl
            lda #0
            sta x_bmask_pidx
            rts


iterate_long_axis   subroutine
                    sub dx,dy
                    bcc shift_y
                    rts
shift_y
                    jsr shift_y
                    rts

shift_y             subroutine
                    iny
                    lda x_bmask_pidx
                    tax
                    clc
                    adc x_bmask_offset,x
                    sta x_bmask_offset,x
                    rts

imagine we start at bit position 4
we'd load the x bit mask pointer for "bytes with bits starting at offset 4"

and move to the right twice 2
we are now at bit position 6
so our x_bmask_pidx = 2

when we increment Y we can use the table i created to find
the next bitmask offset


byte1
byte2
byte3
0
byte1
byte2

drawing algo
initialize ptr0
lda (lstore),y
beq .shift
sta (ptr0),y
.shift

what if i do nothing but just write the x value
16666 cycles per frame
small x line, 918 cycles
jesus, i can only render about 18 lines a frame
f*ck


---------------------
next steps, create table to hold incoming missiles
need to set aside memory for each incoming missile line
render* routines are currently hard coded to pull from 
equate lstore , indirect, Y
how to paramaterize
just load the line data into that ZP pointer
hmm, so the line data would need to include information about
which renderer to use!
how to model -- do I save the address to call, or use a switch ladder BS?
or do we put them in buckets such that we know that all lines in such an such a place
are of type X.  now if the lines are truly random then this might not work well
I need some amount of dynamic behavior.

I also need the a way to have e.g. render1 just draw 1 point from the line
-- question, can I invent some ridiculous 'coroutine' thingy?
i'd need to invent a 'yield' statement
the advantage to this is I don't need to factor all the state out
for example that state in that function is y2,dy, Y and lstore
thoughts: where do you save the context at?
          zero page would be crowded
          the stack?  how would you know when you had come back
          force the user of the coroutine to say?
          
          how would this coroutine thingy work?
          round-robin, everything get's run in order
          a routine can be remove from the list of tasks to run
          a routine that reaches its rts removes itself
          e.g. a line that runs all the way to the end, has hit a city
          and we explode

          so we're designing a little multi-tasking system
          where every missile is a task for the purpose of maybe
          having some easier code to write?

          back to yield
          yield needs to specify where store, what to store
          lda context
          sta dest
          you'd have to swap out the stack , christ ...
          jsr missile
          jsr explosion
          

          you need to store off the stack and restore it each time from some checkpoint
          like:
            save stack pointer
            do stuff
            yield 
              save context in space
              save everything after stack point in context space
              move stack pointer back to before coroutine enter
            select next task
              store stack point
              restore from context
              append to stack for this task
              update stack pointer
              jmp to yield+1

              
           enter_coroutine(id)
           give every routine 10 bytes say?
           can a coroutine start another?
           lda {1}, sta(context),X
           inx
           lda {2}
           
           now i could write some stupid preprocessor?
           Hmm, i don't hate that idea
           otoh, what if the context was just given to you
           as a ZP pointer?
           then all your stuff is lda(context), DY
           speed is the problem, the code generator puts them
           back into your ZP variables for you


the rendering routines always draw from high mem to low mem
that limits them to always drawing quadrants 1 and 2
and what is the point of the increment long axis doing a dec or inc?
i think that is important because it's controlling the short axis
values
