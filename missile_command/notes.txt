TODO:
WOW: this is the last time I worked on this after all the
     medical drama
  4/10
  picking up where left off, double buffering
  the main loop woul be something like this:
  begin time critical
    erase missiles old position
    draw missiles new position
  end time critical
    copy current missile position to old
    update new missile position
  5/3 ( taking some leave after medical drama )
  routine to keep missiles sorted, shortest first
  how do we control the rate of pixel plots on incoming icbm?
  we have framecnt incrementing
  we want to be able to handle anything from < 60fps to > 60fps
  if(framecnt & 3) == 3) then do something for < 60fps
  what about more? we use the fractional technique we used in pacman?
  up to 2xspeed
 
  how can we use framecnt?
  it increments every frame
  increasing series of numbers
  1,2,3,4,5,6
  I guess you could keep a 120ths counter instead of a 60s?
  0,120,240,

  pps = pixels per second
  animating once per frame = 60pps
  animating twice per frame = 120pps
  
  there are 60fps
  Let X = desired PPS
  Then X/60 = number of pixels to move per frame
  example:
    X = 90
    90/60 = 1.5
    we must move 1.5 pixels per frame
    but what does that mean when we only support integer?
    we must 'quantize' that number
    bresenham's was an example of his, where we allow an error term to be summed until it reaches
    a certain.  Quantization = mapping a continous set to a countable ( enumerable? ) set
    
    there must be a frame where we draw 2 pixels and some where we draw 1
    which frames?


    how do you map a set of 90 onto 60 ( that's a surjection ) where
    there is an equivalence class
    what is the surjective function for this?

    first of all we have to make both sets 'countable' so how are we going to represent the set of 90
    {1,2,3 ... 90 }
    {1,2,3 ... 60 }
    that doesn't seem useful as representation because many of the numbers are the same, and then there are some that
    aren't, could we rewrite the numbers?
    
    what will you look for to make the pairings? Division could be useful?
    1.5 - plot R = .5
    .5 + 1.5 = 2 plot,plot R = 0
    1,2,1,2

    each frame must do 1.5 pixels
    so each frame we are adding .5 of a remainder, this is the accumulating error term
    R = .5
    if(r>=1) plot
    R = .5 + .5
    so that takes care of the doubling what about the slowing effect?
    you have to have at least 1 to plot, 2, to plot 2
    we earn some amount of pixels each frame - we can use at most 2
    P=P+.5

    I think I had written a routine to sort interceptor by y length
    i'm not sure if the arcade only draws one pixel at a time or one line height at a time
    i.e. is rate of altitude ascent constant? ( well, up to a point, we only draw 8 pixels at most in one 'frame' )
    there's some not-physics going on here
    the thought with the sorting was anytime a line was done, it would always be the one at the end of the interceptor collection that we would remove , that doesn't take into account a collision can occur.

    the icbm can be destroyed at any time so there is no sense in sorting them
    let's talk about collision detection , perhaps that will inform the design of the 
    data structures employed for icbms
    had the thought of dividing the screen into tiles
    are the lengths always the same?  well, yes, except for the ones launch from planes, sats
    
    what is the best way to check for colissions?
    can we do better than brute force?
    we expect a missile to be near a detonation ( by player intelligence )
    so we will check all active detonations
    check for icbm in all 3 detonation columns
    column, frame#, Y coordinate
    a table of x,y can tell us if there is a hit
    basically an expansion of the explosion bitmap into full byte
    row/col
      01
     +----------------
    0|00
    1|01

    scanning each interceptor for each detonation seems like it would be expensive
    * A detonation at most occupies three screen columns
   
    assume that we've previously iterated through the interceptors and placed the index of the
    interceptor into the apprpriate screen column bucket

    Now as we process each detonation - we only need look in the array of interceptor currently in that
    screen column and check to see if height is "in range"
    we can then go to the master 'lookup table' to see if a collision is in effect

    how expensive is slotting the interceptors into buckets?  well if we do direct indexing, nothing is too expensive right?
    23 columns x 20 interceptors = 460 bytes
    how do you iterate over the 'inceptors' for a screen column efficiently?
    prefix_array = size + elements
    indirect Y
    movw ic_by_column, x, ptr0
    or
    
9/18/21
    can we draw a line starting at the top of the screen and moving downwards?
12/5
    interceptors launch from base
    we can draw lines from top of screen down ( I think I fixed that earlier 
    let's reinstall the icm wave generator
    the call to insertion sort probably needs update to take into account the partitioning of the line_data array
    drawing the icbm doesn't work - I even tried the same line in the interceptro routine and it works, so it's no a sloping issue

7/6/22 ( yes 7 months later ... because DAYJOB )
    debugging icbm_genwave.  It draws the line itself right now, but can the main loop dr aw it, I felt like I debugged this and discovered it was the stupid queue macros not initializing everything
    todo: need to make a table of the collision maps, so that I can load the correct collision map based on the current explosion frame to use for 'hit' tests

2/xx/23
    returning after another time vortex ...
    have no idea where I left off - I think I was about to test if an ICMB and a player interceptor did something
    I need to remember what I was print out dbgmsg 'F' for in line.asm, it was the vicraster, I must have been doing timing for something
    for each detonation
      for each icbm
      
    it makes sense to place the entity that requires the greatest 'precalculation' cost as the outer loop
    e.g. if detonations require a lot of clerical work and icbm data is well cooked, thent he previous loop structure is fastest
    optimization would be to leave data that we need for collision detection hanging around from routines that manipulated that entity
    e.g. the screen column byte could be 'saved' from when we are draing ICBMs since those routines must also calculate that
